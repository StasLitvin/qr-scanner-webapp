<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>QR Scanner</title>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #ffffff;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .header { padding: 16px; text-align: center; width: 100%; background: #16213e; }
    .header h1 { font-size: 18px; font-weight: 600; }
    .header p { font-size: 13px; color: #a0a0b0; margin-top: 4px; }

    .scanner-container {
      position: relative;
      width: 100%;
      max-width: 420px;
      margin: 12px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0 12px;
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid #0f3460;
      background: #000;
    }

    #video {
      width: 100%;
      display: block;
      object-fit: cover;
      min-height: 240px;
    }

    .scan-region {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 210px;
      height: 210px;
      pointer-events: none;
    }

    .scan-region .corner {
      position: absolute;
      width: 30px;
      height: 30px;
      border-color: #e94560;
      border-style: solid;
      border-width: 0;
    }

    .corner.tl { top: 0; left: 0; border-top-width: 4px; border-left-width: 4px; border-radius: 8px 0 0 0; }
    .corner.tr { top: 0; right: 0; border-top-width: 4px; border-right-width: 4px; border-radius: 0 8px 0 0; }
    .corner.bl { bottom: 0; left: 0; border-bottom-width: 4px; border-left-width: 4px; border-radius: 0 0 0 8px; }
    .corner.br { bottom: 0; right: 0; border-bottom-width: 4px; border-right-width: 4px; border-radius: 0 0 8px 0; }

    .scan-line {
      position: absolute;
      left: 10%;
      width: 80%;
      height: 2px;
      background: #e94560;
      animation: scanAnimation 2s linear infinite;
    }

    @keyframes scanAnimation {
      0% { top: 10%; }
      50% { top: 90%; }
      100% { top: 10%; }
    }

    #canvas { display: none; }

    .status {
      margin-top: 12px;
      padding: 12px 14px;
      background: #16213e;
      border-radius: 8px;
      font-size: 14px;
      text-align: center;
      width: 100%;
      line-height: 1.35;
      white-space: pre-line;
    }
    .status.success { background: #1b5e20; }
    .status.error { background: #b71c1c; }
    .status.warning { background: #e65100; }

    .btn-row { display: flex; gap: 8px; margin-top: 12px; width: 100%; flex-wrap: wrap; }

    .btn {
      flex: 1 1 calc(50% - 8px);
      padding: 12px 12px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      color: #fff;
      transition: background 0.2s;
      user-select: none;
    }

    .btn-switch { background: #0f3460; }
    .btn-switch:active { background: #1a5276; }
    .btn-lens { background: #0b6b53; }
    .btn-lens:active { background: #0f8a6a; }
    .btn-flash { background: #533483; }
    .btn-flash:active { background: #6c44a2; }
    .btn-flash.on { background: #f0a500; color: #1a1a2e; }
    .btn-close { background: #b71c1c; }
    .btn-close:active { background: #d32f2f; }

    .debug {
      margin-top: 10px;
      padding: 10px 12px;
      background: #0d0d1a;
      border-radius: 6px;
      font-size: 11px;
      color: #c8c8da;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      word-break: break-word;
      white-space: pre-wrap;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ QR-–∫–æ–¥–∞</h1>
    <p>–ù–∞–≤–µ–¥–∏—Ç–µ –∫–∞–º–µ—Ä—É –Ω–∞ QR-–∫–æ–¥ —É—á–∞—Å—Ç–Ω–∏–∫–∞</p>
  </div>

  <div class="scanner-container">
    <div class="video-wrapper">
      <video id="video" autoplay playsinline muted></video>
      <div class="scan-region">
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
        <div class="scan-line"></div>
      </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="status" id="status">–ó–∞–ø—É—Å–∫...</div>

    <div class="btn-row">
      <button class="btn btn-switch" id="switchBtn">üì∑ –ö–∞–º–µ—Ä–∞</button>
      <button class="btn btn-lens" id="lensBtn">üîÅ –õ–∏–Ω–∑–∞</button>
      <button class="btn btn-flash" id="flashBtn">üî¶ –í—Å–ø—ã—à–∫–∞</button>
      <button class="btn btn-close" id="closeBtn">‚úï –ó–∞–∫—Ä—ã—Ç—å</button>
    </div>

    <div class="debug" id="debug">–õ–æ–≥: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
  </div>

  <!-- jsQR: —Ä–∞–∑–º–µ—Å—Ç–∏—Ç–µ —Ñ–∞–π–ª –Ω–∞ —Å–≤–æ—ë–º —Å–µ—Ä–≤–µ—Ä–µ -->
  <script src="/assets/js/jsQR.min.js"></script>

  <script>
    // =========================
    // DOM
    // =========================
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const statusEl = document.getElementById('status');
    const debugEl = document.getElementById('debug');

    const switchBtn = document.getElementById('switchBtn');
    const lensBtn = document.getElementById('lensBtn');
    const flashBtn = document.getElementById('flashBtn');
    const closeBtn = document.getElementById('closeBtn');

    // =========================
    // Params
    // =========================
    const urlParams = new URLSearchParams(window.location.search);
    const eventId = urlParams.get('event_id') || '0';

    // =========================
    // Logging & UI
    // =========================
    let debugLines = [];
    function log(msg) {
      const time = new Date().toLocaleTimeString();
      const line = `${time} | ${msg}`;
      debugLines.push(line);
      if (debugLines.length > 26) debugLines.shift();
      debugEl.textContent = debugLines.join('\n');
      debugEl.scrollTop = debugEl.scrollHeight;
      console.log('[QR]', msg);
    }

    function setStatus(text, cls) {
      statusEl.textContent = text;
      statusEl.className = 'status' + (cls ? (' ' + cls) : '');
    }

    function waitLoadedMetadata(v) {
      return new Promise((resolve, reject) => {
        const ok = () => { cleanup(); resolve(); };
        const err = () => { cleanup(); reject(new Error('video metadata error')); };
        const cleanup = () => {
          v.removeEventListener('loadedmetadata', ok);
          v.removeEventListener('error', err);
        };
        v.addEventListener('loadedmetadata', ok, { once: true });
        v.addEventListener('error', err, { once: true });
      });
    }

    // =========================
    // Telegram WebApp init (robust)
    // =========================
    let tg = null;
    let isTelegram = false;

    async function initTelegramWebApp() {
      // –ñ–¥—ë–º –¥–æ 2 —Å–µ–∫—É–Ω–¥ (–∏–Ω–æ–≥–¥–∞ API –ø–æ—è–≤–ª—è–µ—Ç—Å—è –Ω–µ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ)
      for (let i = 0; i < 20; i++) {
        const hasTG = !!(window.Telegram && window.Telegram.WebApp);
        if (hasTG) {
          tg = window.Telegram.WebApp;
          isTelegram = true;

          try { tg.ready(); } catch (e) { log('tg.ready err: ' + e.message); }
          try { tg.expand(); } catch (e) { log('tg.expand err: ' + e.message); }

          log('Telegram WebApp –æ–±–Ω–∞—Ä—É–∂–µ–Ω ‚úÖ');
          log('TG version=' + (tg.version || 'n/a') + ', platform=' + (tg.platform || 'n/a'));
          log('TG initData len=' + ((tg.initData && tg.initData.length) ? tg.initData.length : 0));
          try {
            const u = tg.initDataUnsafe || {};
            log('TG user=' + (u.user ? String(u.user.id) : 'none'));
          } catch (e) {
            log('TG initDataUnsafe err: ' + e.message);
          }
          return;
        }
        await new Promise(r => setTimeout(r, 100));
      }

      isTelegram = false;
      tg = null;
      log('TG detect: NO ‚ùå (—Å—Ç—Ä–∞–Ω–∏—Ü–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ù–ï –∫–∞–∫ Telegram WebApp)');
      log('–ü–æ–¥—Å–∫–∞–∑–∫–∞: –æ—Ç–∫—Ä—ã–≤–∞–π—Ç–µ —Å—Ç—Ä–æ–≥–æ –∫–Ω–æ–ø–∫–æ–π web_app –≤ –±–æ—Ç–µ (–Ω–µ —Å—Å—ã–ª–∫–æ–π/–±—Ä–∞—É–∑–µ—Ä–æ–º)');
    }

    // =========================
    // Camera state
    // =========================
    let currentStream = null;
    let currentTrack = null;

    let useFrontCamera = false;
    let flashOn = false;

    let scanActive = true;
    let animFrameId = null;

    // –î–ª—è –æ—Ç—Å–µ—á–µ–Ω–∏—è –¥—É–±–ª–µ–π QR
    let lastQR = null;
    let lastQRTime = 0;

    // –°–∫–∞–Ω–∏—Ä—É–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é –æ–±–ª–∞—Å—Ç—å
    const SCAN_CENTER_FRACTION = 0.6;

    // –ö–∞–º–µ—Ä—ã
    let backCams = [];
    let frontCams = [];
    let backIndex = 0;
    let frontIndex = 0;

    async function refreshDeviceLists() {
      if (!navigator.mediaDevices?.enumerateDevices) return;
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d => d.kind === 'videoinput');

      const isBack = (label) => /back|rear|environment/i.test(label);
      const isFront = (label) => /front|user|selfie/i.test(label);
      const isBadAux = (label) => /macro|depth|tof|aux/i.test(label);

      const scored = vids.map(d => {
        const label = (d.label || '').trim();
        let scoreBack = 0, scoreFront = 0, penalty = 0;

        if (isBack(label)) scoreBack += 10;
        if (isFront(label)) scoreFront += 10;

        if (isBadAux(label)) penalty += 8;
        if (/ultra|wide/i.test(label)) penalty += 2;

        return { deviceId: d.deviceId, label, scoreBack, scoreFront, penalty };
      });

      backCams = scored
        .sort((a,b) => (b.scoreBack - b.penalty) - (a.scoreBack - a.penalty))
        .filter(x => x.scoreBack > 0 || (!x.label && x.deviceId));

      frontCams = scored
        .sort((a,b) => (b.scoreFront - b.penalty) - (a.scoreFront - a.penalty))
        .filter(x => x.scoreFront > 0 || (!x.label && x.deviceId));

      log(`–ù–∞–π–¥–µ–Ω–æ –∫–∞–º–µ—Ä: –≤—Å–µ–≥–æ=${vids.length} back=${backCams.length} front=${frontCams.length}`);
      backCams.slice(0, 5).forEach((c, i) => log('back[' + i + ']: ' + (c.label || '(no label)')));
      frontCams.slice(0, 5).forEach((c, i) => log('front[' + i + ']: ' + (c.label || '(no label)')));
    }

    function buildConstraints({ useDeviceId, deviceId, facingMode }) {
      const baseVideo = {
        width: { ideal: 1920, min: 640 },
        height: { ideal: 1080, min: 480 },
        frameRate: { ideal: 30, min: 15 },
        aspectRatio: { ideal: 16 / 9 },
        resizeMode: { ideal: 'none' }
      };

      if (useDeviceId && deviceId) {
        return { video: { ...baseVideo, deviceId: { exact: deviceId } }, audio: false };
      }
      return { video: { ...baseVideo, facingMode: { ideal: facingMode } }, audio: false };
    }

    async function tuneTrackAndRefocus() {
      if (!currentTrack?.getCapabilities || !currentTrack?.applyConstraints) return;

      try {
        const caps = currentTrack.getCapabilities();
        log('Caps keys: ' + Object.keys(caps).join(', '));

        if (caps.focusMode?.includes('continuous')) {
          try {
            await currentTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
            log('‚Üí focusMode: continuous');
          } catch (e) {
            log('focusMode continuous fail: ' + e.message);
          }
        }

        if (caps.focusMode?.includes('single-shot')) {
          try {
            await currentTrack.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] });
            log('‚Üí focusMode: single-shot (refocus)');
            await new Promise(r => setTimeout(r, 250));
          } catch (e) {
            log('focusMode single-shot fail: ' + e.message);
          }

          if (caps.focusMode?.includes('continuous')) {
            try {
              await currentTrack.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
              log('‚Üí focusMode: continuous (after refocus)');
            } catch (e) {
              log('focusMode back-to-continuous fail: ' + e.message);
            }
          }
        }

        if (caps.focusDistance && caps.focusDistance.min != null && caps.focusDistance.max != null && caps.focusDistance.min !== caps.focusDistance.max) {
          try {
            await currentTrack.applyConstraints({ advanced: [{ focusDistance: caps.focusDistance.min }] });
            log('‚Üí focusDistance: ' + caps.focusDistance.min + ' (near for QR)');
          } catch (e) {
            log('focusDistance fail: ' + e.message);
          }
        }

        log('tune/refocus done');
      } catch (e) {
        log('tune/refocus –æ—à–∏–±–∫–∞: ' + e.message);
      }
    }

    function stopCamera() {
      scanActive = false;
      if (animFrameId) { cancelAnimationFrame(animFrameId); animFrameId = null; }

      if (currentStream) {
        currentStream.getTracks().forEach(t => t.stop());
        currentStream = null;
        currentTrack = null;
      }
      video.srcObject = null;
    }

    async function startCamera() {
      stopCamera();

      const facingMode = useFrontCamera ? 'user' : 'environment';
      setStatus('–ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã...', 'warning');
      log('–ó–∞–ø—É—Å–∫: ' + facingMode);

      let stream = null;
      try {
        stream = await navigator.mediaDevices.getUserMedia(buildConstraints({ useDeviceId: false, facingMode }));
        log('–ö–∞–º–µ—Ä–∞ OK (–ø–µ—Ä–≤–∏—á–Ω—ã–π —Å—Ç–∞—Ä—Ç –ø–æ facingMode)');
      } catch (e) {
        log('–°—Ç–∞—Ä—Ç –ø–æ facingMode fail: ' + e.name + ' / ' + e.message);
      }

      if (!stream) {
        setStatus('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ', 'error');
        return;
      }

      currentStream = stream;
      currentTrack = stream.getVideoTracks()[0];
      video.srcObject = stream;

      try { await refreshDeviceLists(); } catch (e) { log('enumerateDevices –æ—à–∏–±–∫–∞: ' + e.message); }

      const chosen = useFrontCamera
        ? (frontCams[frontIndex]?.deviceId)
        : (backCams[backIndex]?.deviceId);

      if (chosen) {
        log('–ü—Ä–æ–±—É—é ' + (useFrontCamera ? '—Ñ—Ä–æ–Ω—Ç' : '–∑–∞–¥–Ω—é—é') + ' –ø–æ deviceId (index=' + (useFrontCamera ? frontIndex : backIndex) + ')');
        try {
          stream.getTracks().forEach(t => t.stop());
          stream = await navigator.mediaDevices.getUserMedia(buildConstraints({ useDeviceId: true, deviceId: chosen, facingMode }));
          currentStream = stream;
          currentTrack = stream.getVideoTracks()[0];
          video.srcObject = stream;
          log('–û—Ç–∫—Ä—ã—Ç–∞ ' + (useFrontCamera ? '—Ñ—Ä–æ–Ω—Ç' : '–∑–∞–¥–Ω—è—è') + ' –∫–∞–º–µ—Ä–∞ –ø–æ deviceId ‚úÖ');
        } catch (e) {
          log('deviceId —Å—Ç–∞—Ä—Ç fail: ' + e.name + ' / ' + e.message);
        }
      }

      try {
        const s = currentTrack.getSettings();
        log(`Track settings: ${s.width || '?'}x${s.height || '?'} facing=${s.facingMode || '?'} deviceId=${s.deviceId ? 'yes' : 'no'}`);
      } catch (e) {}

      try { await waitLoadedMetadata(video); }
      catch (e) { setStatus('–û—à–∏–±–∫–∞ –≤–∏–¥–µ–æ', 'error'); return; }

      await tuneTrackAndRefocus();

      flashOn = false;
      flashBtn.classList.remove('on');

      try { await video.play(); }
      catch (e) { setStatus('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è', 'error'); return; }

      log('–í–∏–¥–µ–æ: ' + video.videoWidth + 'x' + video.videoHeight);

      if (!isTelegram) {
        setStatus(
          '–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ò—â—É QR-–∫–æ–¥...\n(–í–ù–ò–ú–ê–ù–ò–ï: –æ—Ç–∫—Ä—ã—Ç –Ω–µ –∫–∞–∫ WebApp ‚Äî –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ –±–æ—Ç –Ω–µ –±—É–¥–µ—Ç)',
          'warning'
        );
      } else {
        setStatus('–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ò—â—É QR-–∫–æ–¥...', 'success');
      }

      scanActive = true;
      requestScan();
    }

    // =========================
    // Flash / torch
    // =========================
    async function toggleFlash() {
      if (!currentTrack) return;
      try {
        const caps = currentTrack.getCapabilities ? currentTrack.getCapabilities() : {};
        if (!caps.torch) {
          setStatus('–í—Å–ø—ã—à–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞', 'warning');
          setTimeout(() => setStatus('–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ò—â—É QR-–∫–æ–¥...', isTelegram ? 'success' : 'warning'), 1500);
          return;
        }
        flashOn = !flashOn;
        await currentTrack.applyConstraints({ advanced: [{ torch: flashOn }] });
        flashBtn.classList.toggle('on', flashOn);
        log('–í—Å–ø—ã—à–∫–∞: ' + (flashOn ? '–í–ö–õ' : '–í–´–ö–õ'));
      } catch (e) {
        log('–í—Å–ø—ã—à–∫–∞ –æ—à–∏–±–∫–∞: ' + e.message);
      }
    }

    // =========================
    // Scanning loop
    // =========================
    function requestScan() {
      if (!scanActive) return;
      animFrameId = requestAnimationFrame(scanFrame);
    }

    function scanFrame() {
      if (!scanActive) return;

      // jsQR must exist
      if (typeof jsQR !== 'function') {
        setStatus('–û—à–∏–±–∫–∞: jsQR –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ /assets/js/jsQR.min.js', 'error');
        log('jsQR is not loaded');
        scanActive = false;
        return;
      }

      if (video.readyState !== video.HAVE_ENOUGH_DATA) {
        requestScan();
        return;
      }

      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) {
        requestScan();
        return;
      }

      const cropW = Math.floor(w * SCAN_CENTER_FRACTION);
      const cropH = Math.floor(h * SCAN_CENTER_FRACTION);
      const cropX = Math.floor((w - cropW) / 2);
      const cropY = Math.floor((h - cropH) / 2);

      canvas.width = cropW;
      canvas.height = cropH;
      ctx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, cropW, cropH);

      let imageData;
      try {
        imageData = ctx.getImageData(0, 0, cropW, cropH);
      } catch (e) {
        requestScan();
        return;
      }

      const code = jsQR(imageData.data, cropW, cropH, { inversionAttempts: 'attemptBoth' });
      if (code && code.data) {
        onQRDetected(code.data);
        return;
      }

      requestScan();
    }

    function resumeScanAfterDelay(ms = 2500) {
      setTimeout(() => {
        scanActive = true;
        requestScan();
        setStatus('–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –ò—â—É QR-–∫–æ–¥...', isTelegram ? 'success' : 'warning');
      }, ms);
    }

    // =========================
    // QR detected -> sendData
    // =========================
    function onQRDetected(qrData) {
      scanActive = false;

      // Dedupe within 4 seconds
      const now = Date.now();
      if (qrData === lastQR && (now - lastQRTime) < 4000) {
        log('–î—É–±–ª—å QR –≤ —Ç–µ—á–µ–Ω–∏–µ 4—Å ‚Äî –∏–≥–Ω–æ—Ä');
        scanActive = true;
        requestScan();
        return;
      }
      lastQR = qrData;
      lastQRTime = now;

      log('QR: ' + qrData);
      log('onQRDetected: isTelegram=' + isTelegram + ', hasTG=' + !!(window.Telegram && window.Telegram.WebApp));

      try { if (navigator.vibrate) navigator.vibrate(150); } catch (e) {}

      // IMPORTANT: key must match bot handler -> qr_data
      const payloadObj = {
        event_id: Number(eventId),
        qr_data: String(qrData || '')
      };
      const payload = JSON.stringify(payloadObj);
      log('PayloadObj: ' + JSON.stringify(payloadObj));

      if (!isTelegram || !tg) {
        setStatus('QR —Å—á–∏—Ç–∞–Ω ‚úÖ\n–ù–æ –æ—Ç–∫—Ä—ã—Ç –Ω–µ –∫–∞–∫ Telegram WebApp ‚Äî –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ –±–æ—Ç –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞', 'error');
        log('SEND SKIP: no Telegram WebApp context');
        resumeScanAfterDelay(3000);
        return;
      }

      try {
        tg.sendData(payload);
        log('sendData() OK ‚úÖ');
        setStatus('üì® –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –±–æ—Ç–∞', 'success');

        // Close a bit later to avoid races
        setTimeout(() => {
          try { tg.close(); } catch (e) { log('tg.close err: ' + e.message); }
        }, 700);

      } catch (e) {
        log('sendData –æ—à–∏–±–∫–∞: ' + (e?.message || String(e)));
        setStatus('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram WebApp', 'error');
        resumeScanAfterDelay(3000);
      }
    }

    // =========================
    // Buttons
    // =========================
    switchBtn.addEventListener('click', () => {
      useFrontCamera = !useFrontCamera;
      log('–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ: ' + (useFrontCamera ? '—Ñ—Ä–æ–Ω—Ç' : '–∑–∞–¥–Ω—è—è'));
      startCamera();
    });

    lensBtn.addEventListener('click', () => {
      if (useFrontCamera) {
        if (frontCams.length <= 1) { setStatus('–ù–µ—Ç –¥—Ä—É–≥–∏—Ö —Ñ—Ä–æ–Ω—Ç –∫–∞–º–µ—Ä', 'warning'); return; }
        frontIndex = (frontIndex + 1) % frontCams.length;
        log('–õ–∏–Ω–∑–∞ —Ñ—Ä–æ–Ω—Ç: index=' + frontIndex);
      } else {
        if (backCams.length <= 1) { setStatus('–ù–µ—Ç –¥—Ä—É–≥–∏—Ö –∑–∞–¥–Ω–∏—Ö –∫–∞–º–µ—Ä', 'warning'); return; }
        backIndex = (backIndex + 1) % backCams.length;
        log('–õ–∏–Ω–∑–∞ –∑–∞–¥–Ω—è—è: index=' + backIndex);
      }
      startCamera();
    });

    flashBtn.addEventListener('click', () => toggleFlash());

    closeBtn.addEventListener('click', () => {
      stopCamera();
      if (isTelegram && tg) { try { tg.close(); } catch (e) {} }
      setStatus('–°–∫–∞–Ω–µ—Ä –∑–∞–∫—Ä—ã—Ç', 'warning');
    });

    // =========================
    // Main
    // =========================
    async function main() {
      log('event_id = ' + eventId);

      // Telegram first (so status can warn correctly)
      await initTelegramWebApp();

      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        log('getUserMedia OK');
        startCamera();
      } else {
        setStatus('–ö–∞–º–µ—Ä–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è', 'error');
        log('getUserMedia –ù–ï –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è');
        if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
          setStatus('–ù—É–∂–µ–Ω HTTPS! –ü—Ä–æ—Ç–æ–∫–æ–ª: ' + location.protocol, 'error');
        }
      }
    }

    main();
  </script>
</body>
</html>
